---
title: "inferring the infection pathway of influenza"
author: "aya43@sfu.ca; mhayati@sfu.ca"
date: '2018-07-09'
output:
  html_document:
    theme: yeti
    highlight: "zenburn"
    number_sections: true
    toc: true
    toc_float: 
      collapsed: true
      smooth_scroll: false
    df_print: paged
---

# logistics

remember to edit "root" to your home directory!

```{r warning=F}
# load packages
pkgs = c("ape", "phangorn", "seqinr", "phytools", 
         "plotly", "dplyr", "tidyr", "seqLogo", "Matrix",
         "geosphere", "leaflet")
pkgs_ui = setdiff(pkgs, rownames(installed.packages()))
if (length(pkgs_ui) > 0) install.packages(pkgs_ui, verbose=F)
sapply(pkgs, require, character.only=T)

# set paths
root = "~/projects/ai4all-sfu_bio"

seq_dir = paste(root, "/data/FASTA.fa", sep="") #original genetic sequence
meta_dir = paste(root, "/data/meta.csv", sep="")
align_dir = paste(root, "/data/alignment.fa", sep="")

result_dir_ = paste(root, "/result", sep=""); dir.create(result_dir_, showWarnings=F)

# use a previous result; set to "" if starting anew
result_time_ = ""

# options
nseq = 200 #number of sequences to sample; 2*nseq < total # of sequences
```

## align influenza virus genetic sequences

```{r message=F, warning=F}
# load sequence alignments; to align sequences, install mafft @ (https://mafft.cbrc.jp/alignment/software/)
if (!file.exists(align_dir)) system(paste("mafft ", seq_dir, " > ", align_dir, sep=""))
align = read.dna(align_dir, format="fasta")
strains_id = rownames(align)
strains = sapply(strsplit(strains_id,"[-]"), function(x) x[1])
dates = as.Date(sapply(strsplit(strains_id,"[-]"), function(x) x[2]))
```

## load/subset results

```{r}
#sample for more recent strains
set.seed(17)
result_time = ifelse(result_time_=="", gsub(" ", "_", gsub("[:]", "-", Sys.time())), result_time_)
result_dir = paste(result_dir_, "/", result_time, sep=""); dir.create(result_dir, showWarnings=F)
ind_dir = paste(result_dir, "/ind.csv", sep="")

if (result_time_ == "") {
  sam_ind = rownames(align)[sample(c(1:min(2*nseq,nrow(align))), nseq, replace=F, prob=NULL)]
  write.csv(sam_ind, file=ind_dir, row.names=F)
}
sam_ind = read.csv(ind_dir, stringsAsFactors=F)[,1]
```

# infer phylogeny (ancestral tree)

## UPGMA

calculate distance between sequences

```{r}
align_n = align[sam_ind,]
align_n = as.phyDat(align_n)
dm = dist.ml(align_n, model="JC69")
```

infer the tree using upgma

```{r}
tree_UPGMA = upgma(dm)
plot(tree_UPGMA, show.tip.label=F, main="UPGMA")
```

## neighbour joining (nj)

infer the tree using nj

```{r}
# mt = modelTest(align_n)
# print(mt)
tree_NJ = NJ(dm)
plot(tree_NJ, main="Phylogeny: Neighbour Joining", show.tip.label=F)
tree = ladderize(tree_NJ)
plot(tree, main="Phylogeny: Neighbour Joining", show.tip.label=F)
is.rooted(tree_NJ) #is tree rooted
is.binary(tree_NJ) #are tree branches binary
```

but which of these trees is a better fit for your data? Using the parsimony() function, you can compare their respective parsimony scores. 

```{r}
parsimony(tree_UPGMA, align_n)
parsimony(tree_NJ, align_n)
```

optim.parsimony tries to find the maximum parsimony tree using either Nearest Neighbor Interchange (NNI) rearrangements or sub tree pruning and regrafting (SPR).

```{r}
tree_optim = optim.parsimony(tree_NJ,align_n)
tree_pratchet = pratchet(align_n)
plot(tree_optim, main="Phylogeny: Maximum Parsimony NNI", show.tip.label=F)
plot(tree_pratchet, main="Phylogeny: Maximum Parsimony SPR", show.tip.label=F)
```

## maximum likelihood

maximum likelihood methods allow you to include the full data from your sequence alignment in a statistical framework that estimates model parameters.

the first thing we need to do is create a special type of object of class “pml”. This object includes mostly our tree and data, but also parameters of an evolutionary model, their values (usually set to some default), and the likelihood of the model. 

```{r}
fit = pml(tree_NJ,align_n)
print(fit)
plot(fit, main="Phylogeny: Neighbour Joining (PML)", show.tip.label=F)
```

function optim.pml() will optimize tree topology and branch length for your selected model of nucleotide evolution.

```{r}
fitJC = optim.pml(fit, model="JC", rearrangement="stochastic")
logLik(fitJC)
plot(fitJC, main="Phylogeny: Neighbour Joining Optimized (PML)", show.tip.label=F)
```

note that the object returned by optim.pml is not a phylogeny, but an optimized object of class "pml" (which contains an optimized phylogeny with edge lengths). Let’s plot this phylogeny:

```{r}
tree_JC = fitJC$tree
plot(tree_JC, type="phylogram",  lab4ut="horizontal", edge.width = 2, show.tip.label=F)
```

# infer ancestral sequences

## reconstruct ancestrial sequences

```{r}
# what tree do we want to do ancestral sequence reconstruction for?
tree_type = "NJ"
tree = tree_NJ

# convert alignment format
align_npd = phyDat(align_n) 

# parsimony reconstructions: based on the fitch algorithm for bifurcating trees (note: there will be often no unique solution)
anc = ancestral.pars(tree, align_npd, "ACCTRAN")
plotAnc(tree, anc, cex.pie=.5, show.tip.label=F)
title(paste0(tree_type, ": ACCTRAN"))
```

## match ancestral sequences with known strains

align known influenza virus with ancestral sequences; known strains must have a date preceding their child strains; we assume there are at least 2 layers in a tree

```{r}
# get sequences ready (combine ancestral with known strains)
seqa_dir = paste(result_dir, "/FASTA_anc.fa", sep="")
sequ_anc = as.DNAbin(lapply(anc, function(x) colnames(x)[apply(x,1,function(y) which.max(y))] ))
write.dna(sequ_anc, file=seqa_dir, format="fasta")

sequ = read.dna(seq_dir, format="fasta")
sequ_anc = read.dna(seqa_dir, format="fasta", as.matrix=F)

seq_all_dir = paste(result_dir, "/FASTA_all.fa", sep="")
sequ_all = append(sequ_anc, sequ)
sequ_all = sequ_all[!(duplicated(names(sequ_all)) | duplicated(names(sequ_all),fromLast=T))] # leaf sequences not included in distance calulcation
write.dna(sequ_all, file=seq_all_dir, format="fasta")

# align sequences, install mafft @ (https://mafft.cbrc.jp/alignment/software/)
align_anc_dir = paste(result_dir, "/alignment_anc.fa", sep="")
if (!file.exists(align_anc_dir)) system(paste("mafft ", seq_all_dir, " > ", align_anc_dir, sep=""))
align_anc = read.dna(align_anc_dir, format="fasta")
```

calculate distance (ancestral sequences x known sequences) from alignments

```{r}
# get distances ready
dm_anc_dir = paste(result_dir, "/dm_anc.Rdata", sep="")
if (!file.exists(dm_anc_dir)) {
  dm_anc = dist.ml(phyDat(align_anc),model="JC69")
  save(dm_anc, file=dm_anc_dir)
}
dm_anc = as.matrix(get(load(dm_anc_dir)), sparse=T)
dm_anc = dm_anc[!rownames(dm_anc)%in%strains_id, colnames(dm_anc)%in%strains_id]
strains_anc = sapply(strsplit(colnames(dm_anc),"[-]"), function(x) x[1])
dates_anc = as.Date(sapply(strsplit(colnames(dm_anc),"[-]"), function(x) x[2]))
names(dates_anc) = strains_anc
```

label tree nodes

```{r}
evo_month = 444 # max number of months needed for a parent strain to evolve into a child strain (max = 444)

# load metadata
meta = read.csv(meta_dir, stringsAsFactors=1)[,-1]
rownames(meta) = meta[,"strain"]

# label nodes starting from root using depth first search
edges = tree$edge[order(tree$edge[,2]),] #first nseq nodes are leaves
edges[1:nseq,2] = tree$tip.label
edges[,2] = sapply(strsplit(edges[,2], "[-]"), function(x) x[1])

tree_labelled = T
nodes = unique(as.vector(edges))
node = unique(edges[!edges[,1]%in%edges[,2],1]) #root
while (sum(!nodes%in%strains)>0) {
  children = sapply(strsplit(edges[edges[,1]==node, 2], "[-]"), function(x) x[1])
  if (any(!children%in%strains)) {
    node = children[!children%in%strains]
    node = node[1]
  } else {
    min_date = min(as.Date(as.character(meta[children, "date"])))
    min_date_ = seq(min_date, length=2, by="-6 months")[2]
    dm_colind = which(dates_anc < min_date & dates_anc > min_date_ &
                        !names(dates_anc)%in%edges)
    if (length(dm_colind)==0) {
      print("incomplete! need data on older strains")
      tree_labelled = F; break()
    }
    edges[edges==node] = nodes[nodes==node] = node_strain = 
      names(dm_colind[which.min(dm_anc[node, dm_colind])])
    # nodes_in = setdiff(nodes_in, node)
    node = edges[edges[,2]==node_strain, 1]
  }
}
```

## plot

prepare nodelist virus & edgelist vphy

```{r}
# viral strains
virus = meta[nodes, c("strain", "subtype", "date", "lng", "lat")]

# viral phylogeny
vphy = data.frame(id=seq_len(nrow(edges)),
                  start_lng=meta[edges[,1], "lng"], start_lat=meta[edges[,1], "lat"],
                  end_lng=meta[edges[,2], "lng"], end_lat=meta[edges[,2], "lat"])
```

plot map

```{r}
# heat colours: red (early) to yellow (recent)
colours = sapply(heat.colors(length(unique(meta$date))), function(x) gsub("FF$","",x))
names(colours) = sort(unique(meta$date))

# phylogeny edges
geo_lines = gcIntermediate(vphy[,c("start_lng", "start_lat")], 
                           vphy[,c("end_lng", "end_lat")], 
                           n=200, addStartEnd=T, sp=T, breakAtDateLine=T)

# map
leaflet() %>% 
  addMiniMap(tiles = providers$Esri.OceanBasemap, width = 120, height=80) %>%
  addProviderTiles(providers$Esri.OceanBasemap) %>% 
  addCircleMarkers(data=virus, lng=~lng, lat=~lat,
                   color = as.vector(colours[virus[,"date"]]), weight=2, radius=2,
                   label=paste(virus[,"subtype"], " (", 
                               virus[,"strain"], ") ", 
                               virus[,"date"], sep="")) %>%
  addPolylines(data=geo_lines, color = as.vector(colours[meta[edges[,2],"date"]]),
               weight = 1, opacity = 0.5, fill = FALSE, fillOpacity = 0.5, label = NULL)
```
