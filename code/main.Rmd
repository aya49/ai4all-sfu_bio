---
title: "inferring the infection pathway of influenza"
author: "aya43@sfu.ca; mhayati@sfu.ca"
date: '2018-07-09'
output:
  html_document:
    theme: yeti
    highlight: "neon"
    number_sections: true
    toc: true
    toc_float: 
      collapsed: true
      smooth_scroll: false
    df_print: paged
---

# logistics

```{r warning=FALSE}
# load packages
pkgs = c("ape", "phangorn", "seqinr", "phytools", "plotly", "dplyr", "seqLogo")
pkgs_ui = setdiff(pkgs, rownames(installed.packages()))
if (length(pkgs_ui) > 0) install.packages(pkgs_ui, verbose=F)
sapply(pkgs, require, character.only=TRUE)

# set paths
root = "~/projects/ai4all-sfu_bio"

seq_dir = paste(root, "/data/FASTA.fa", sep="") #original genetic sequence
meta_dir = paste(root, "/data/meta.csv", sep="")

result_dir = paste(root, "/result", sep=""); dir.create(result_dir, showWarnings=F)
align_dir = paste(result_dir, "/alignment_mafft.fa", sep="")

# options
nseq = 200 #number of sequences to sample; 2nseq < total_no_of_sequences
```

# prepare influenza virus genetic sequences, alignments, and metadata

```{r warning=FALSE}
# load sequences
sequ = read.dna(seq_dir, format="fasta")

# align sequences; to align sequences, install mafft @ (https://mafft.cbrc.jp/alignment/software/)
if (!file.exists(align_dir)) system(paste("mafft ", seq_dir, " > ", align_dir, sep=""))

align = read.dna(align_dir, format="fasta")
strains = sapply(strsplit(rownames(align),"[-]"), function(x) x[1])
dates = as.Date(sapply(strsplit(rownames(align),"[-]"), function(x) x[2]))

meta = read.csv(meta_dir, row.names=1)
```

# infer phylogeny (ancestral tree)

## UPGMA

calculate distance between sequences

```{r}
set.seed(17)
sam_ind = sample(c(1:min(2*nseq,nrow(align))), nseq, replace=FALSE, prob=NULL) #sample for more recent strains
align_n = align[sam_ind, ]
align_n = as.phyDat(align_n)
dm = dist.ml(align_n,model="JC69")
```

infer the tree using upgma

```{r}
tree_UPGMA = upgma(dm)
plot(tree_UPGMA, show.tip.label=FALSE, main="UPGMA")
```

## neighbour joining (nj)

infer the tree using nj

```{r}
# mt = modelTest(align_n)
# print(mt)
tree_NJ = NJ(dm)
plot(tree_NJ, main="Phylogeny: Neighbour Joining", show.tip.label=FALSE)
tree = ladderize(tree_NJ)
plot(tree, main="Phylogeny: Neighbour Joining", show.tip.label=FALSE)
is.rooted(tree_NJ) #is tree rooted
is.binary(tree_NJ) #are tree branches binary
```

but which of these trees is a better fit for your data? Using the parsimony() function, you can compare their respective parsimony scores. 

```{r}
parsimony(tree_UPGMA, align_n)
parsimony(tree_NJ, align_n)
```

optim.parsimony tries to find the maximum parsimony tree using either Nearest Neighbor Interchange (NNI) rearrangements or sub tree pruning and regrafting (SPR).

```{r}
tree_optim = optim.parsimony(tree_NJ,align_n)
tree_pratchet = pratchet(align_n)
plot(tree_optim, main="Phylogeny: Maximum Parsimony NNI", show.tip.label=FALSE)
plot(tree_pratchet, main="Phylogeny: Maximum Parsimony SPR", show.tip.label=FALSE)
```

## maximum likelihood

maximum likelihood methods allow you to include the full data from your sequence alignment in a statistical framework that estimates model parameters.

the first thing we need to do is create a special type of object of class “pml”. This object includes mostly our tree and data, but also parameters of an evolutionary model, their values (usually set to some default), and the likelihood of the model. 

```{r}
fit = pml(tree_NJ,align_n)
print(fit)
plot(fit, main="Phylogeny: Neighbour Joining (PML)", show.tip.label=FALSE)
```

function optim.pml() will optimize tree topology and branch length for your selected model of nucleotide evolution.

```{r}
fitJC = optim.pml(fit, model="JC", rearrangement="stochastic")
logLik(fitJC)
plot(fitJC, main="Phylogeny: Neighbour Joining Optimized (PML)", show.tip.label=FALSE)
```

note that the object returned by optim.pml is not a phylogeny, but an optimized object of class “pml” (which contains an optimized phylogeny with edge lengths). Let’s plot this phylogeny:

```{r}
tree_JC = fitJC$tree
plot(tree_JC, type="phylogram",  lab4ut="horizontal", edge.width = 2, show.tip.label=FALSE)
```

# infer ancestral sequences

load all viral strains & their metadata

```{r}

```

reconstruct ancestrial sequences

```{r}
# convert alignment format
align_npd = phyDat(align_n) 

# what trees do we want to do ancestral sequence reconstruction for?
tree_type = "NJ"
tree = tree_NJ
fitpml_type = "NJ_JC"
fitpml = fitJC

# parsimony reconstructions: based on the fitch algorithm for bifurcating trees (note: there will be often no unique solution)
anc_mpr = ancestral.pars(tree, align_npd, "MPR")
plotAnc(tree, anc.mpr, cex.pie=.5, show.tip.label=FALSE)
title(paste0(tree_type, ": MPR"))

anc_acctran = ancestral.pars(tree, align_npd, "ACCTRAN")
plotAnc(tree, anc.acctran, cex.pie=.5, show.tip.label=FALSE)
title(paste0(tree_type, ": ACCTRAN"))

# #see subset of inferred sequence
# seqLogo(t(subset(anc.mpr, getRoot(tree), 1:20)[[1]]), ic.scale=FALSE)

# #maximum likelihood reconstructions
# anc_ml = ancestral.pml(fitpml, "ml")
# plotAnc(tree, anc_ml, cex.pie=.5, show.tip.label=FALSE)
# title(paste0(fitpml_type, " PML: Max Likelihood"))
# 
# anc_bayes = ancestral.pml(fitpml, "bayes")
# plotAnc(tree, anc_bayes, cex.pie=.5, show.tip.label=FALSE)
# title(paste0(fitpml_type, " PML: Bayes"))

```

match ancestrial sequences with those in strains that have a date preceding the ancestor's two child sequences

here we assume there are at least 2 layers in a tree and that 2nseq<=nrow(align)

```{r}
# what anccestral reconstruction sequences we want to map out?
anc_type = "parsimony_acctran"
anc = phyDat(anc_acctran)
edges = tree$edge[order(tree$edge[,2]),] #first nseq nodes are leaves

# get sequences ready!
sequ_non = sequ[!names(sequ)%in%rownames(align)[sam_ind]]

# get distances ready
dm_all = dist.ml(phyDat(align_anc),model="JC69")

# get alignments ready
align_non = align[!sam_ind]

gsub(" ","_",gsub("[:]","-",Sys.time()))


leaves = 1:nseq
root = unique(edges[!edges[,1]%in%edges[,2],1])
while (length(leaves)>0) {
  parents = unique(edges[edges[,2]%in%leaves,1])
  for (parent in parents) {
    parent_seq = colnames(anc[[parent]])[apply(parent_seq, 1, function(x) which.max(x))]
    
  }
  leaves = parents
}


```

make nodelist virus & edgelist vphy

```{r}
# viral strains
virus
# columns: 
# long (longitude), 
# lat (latitude), 
# strain (strain name), 
# sig (size of virus impact for plot size), 
# time (tiem of infection?), etc.

# viral phylogeny
vphy
vphy$id = seq_len(nrow(vphy))
# columns:
# start_long (longitude), 
# start_lat (latitude), 
# end_long (longitude), 
# end_lat (latitude)
```

plot map

```{r}
# map attributes
geos = list(
  #scope = 'north america',
  projection = list(type = 'azimuthal equal area'),
  showland = TRUE,
  landcolor = toRGB("gray95"),
  countrycolor = toRGB("gray80")
)

# map plot
p = plot_geo(locationmode = 'USA-states', color = I("red")) %>%
  add_markers(
    data = virus, x = ~long, y = ~lat, text = ~strain,
    size = ~sig, hoverinfo = "text", alpha = 0.5
  ) %>%
  add_segments(
    data = group_by(vphy, id),
    x = ~start_lon, xend = ~end_lon,
    y = ~start_lat, yend = ~end_lat,
    alpha = 0.3, size = I(1), hoverinfo = "none"
  ) %>%
  layout(
    title='Influenza Virus Infection Map',
    geo=geos, showlegend=FALSE, heights=800
  )

# shareable link to map
chart_link = api_create(p, filename="virus")
```
